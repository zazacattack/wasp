"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3549],{85162:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(67294),s=a(86010);const i={tabItem:"tabItem_Ymn6"};function r(e){let{children:t,hidden:a,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,s.Z)(i.tabItem,r),hidden:a},t)}},74866:(e,t,a)=>{a.d(t,{Z:()=>T});var n=a(87462),s=a(67294),i=a(86010),r=a(12466),o=a(16550),l=a(91980),u=a(67392),p=a(50012);function c(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:s}}=e;return{value:t,label:a,attributes:n,default:s}}))}function d(e){const{values:t,children:a}=e;return(0,s.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function k(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(i),(0,s.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function h(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,i=d(e),[r,o]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[l,u]=k({queryString:a,groupId:n}),[c,h]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,p.Nk)(a);return[n,(0,s.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:n}),y=(()=>{const e=l??c;return m({value:e,tabValues:i})?e:null})();(0,s.useLayoutEffect)((()=>{y&&o(y)}),[y]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),h(e)}),[u,h,i]),tabValues:i}}var y=a(72389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:a,selectedValue:o,selectValue:l,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.o5)(),d=e=>{const t=e.currentTarget,a=p.indexOf(t),n=u[a].value;n!==o&&(c(t),l(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=p.indexOf(e.currentTarget)+1;t=p[a]??p[0];break}case"ArrowLeft":{const a=p.indexOf(e.currentTarget)-1;t=p[a]??p[p.length-1];break}}t?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:r}=e;return s.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>p.push(e),onKeyDown:m,onClick:d},r,{className:(0,i.Z)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":o===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;const i=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===n));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function w(e){const t=h(e);return s.createElement("div",{className:(0,i.Z)("tabs-container",g.tabList)},s.createElement(f,(0,n.Z)({},e,t)),s.createElement(v,(0,n.Z)({},e,t)))}function T(e){const t=(0,y.Z)();return s.createElement(w,(0,n.Z)({key:String(t)},e))}},48863:(e,t,a)=>{a.d(t,{A:()=>r,v:()=>o});var n=a(67294),s=a(50012),i=a(70143);function r(e){let{children:t}=e;const[a]=(0,s.Nk)("docusaurus.tab.js-ts");return"ts"===a&&n.createElement(i.Z,null,t)}function o(e){let{children:t}=e;const[a]=(0,s.Nk)("docusaurus.tab.js-ts");return"js"===a&&n.createElement(i.Z,null,t)}},18089:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>y,frontMatter:()=>u,metadata:()=>c,toc:()=>m});var n=a(87462),s=(a(67294),a(3905)),i=a(85162),r=a(74866),o=a(44996),l=a(48863);const u={id:"03-listing-tasks",title:"Listing tasks"},p=void 0,c={unversionedId:"tutorials/todo-app/03-listing-tasks",id:"tutorials/todo-app/03-listing-tasks",title:"Listing tasks",description:"We want to admire our tasks, so let's list them!",source:"@site/docs/tutorials/todo-app/03-listing-tasks.md",sourceDirName:"tutorials/todo-app",slug:"/tutorials/todo-app/03-listing-tasks",permalink:"/docs/tutorials/todo-app/03-listing-tasks",draft:!1,editUrl:"https://github.com/wasp-lang/wasp/edit/main/web/docs/tutorials/todo-app/03-listing-tasks.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"03-listing-tasks",title:"Listing tasks"},sidebar:"docs",previous:{title:"Task entity",permalink:"/docs/tutorials/todo-app/02-task-entity"},next:{title:"Creating tasks",permalink:"/docs/tutorials/todo-app/04-creating-tasks"}},d={},m=[{value:"Introducing operations (queries and actions)",id:"introducing-operations-queries-and-actions",level:2},{value:"Defining the Query",id:"defining-the-query",level:2},{value:"Wasp declaration",id:"wasp-declaration",level:3},{value:"JavaScript implementation",id:"javascript-implementation",level:3},{value:"TypeScript implementation",id:"typescript-implementation",level:3},{value:"Invoking the Query on the frontend",id:"invoking-the-query-on-the-frontend",level:2}],k={toc:m},h="wrapper";function y(e){let{components:t,...a}=e;return(0,s.kt)(h,(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"We want to admire our tasks, so let's list them!"),(0,s.kt)("h2",{id:"introducing-operations-queries-and-actions"},"Introducing operations (queries and actions)"),(0,s.kt)("p",null,"The primary way of interacting with entities in Wasp is via ",(0,s.kt)("a",{parentName:"p",href:"/docs/language/features#queries-and-actions-aka-operations"},"operations (queries and actions)"),"."),(0,s.kt)("p",null,"Queries are here when we need to fetch/read something, while actions are here when we need to change/update something.\nWe will start with writing a query, since we are just listing tasks and not modifying anything for now."),(0,s.kt)("p",null,"To list tasks, we will need two things:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"A Wasp query that fetches all the tasks from the database."),(0,s.kt)("li",{parentName:"ol"},"React logic that calls our query and displays its results.")),(0,s.kt)("h2",{id:"defining-the-query"},"Defining the Query"),(0,s.kt)("p",null,"Let's implement ",(0,s.kt)("inlineCode",{parentName:"p"},"getTasks")," ",(0,s.kt)("a",{parentName:"p",href:"/docs/language/features#query"},"query"),"."),(0,s.kt)(l.v,{mdxType:"ShowForJs"},(0,s.kt)("p",null,"It consists of a declaration in Wasp and implementation in JS (in ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server/")," directory).")),(0,s.kt)(l.A,{mdxType:"ShowForTs"},(0,s.kt)("p",null,"It consists of a declaration in Wasp and implementation in TS (in ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server/")," directory).")),(0,s.kt)("h3",{id:"wasp-declaration"},"Wasp declaration"),(0,s.kt)("p",null,"Add the following code to ",(0,s.kt)("inlineCode",{parentName:"p"},"main.wasp"),":"),(0,s.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},"// ...\n\nquery getTasks {\n  // We specify that JS implementation of the query (which is an async JS function)\n  // can be found in `src/server/queries.js` as the named export `getTasks`.\n  // Use '@server' to reference files inside the src/server folder.\n  fn: import { getTasks } from \"@server/queries.js\",\n  // We tell Wasp that this query is doing something with entity `Task`. With that, Wasp will\n  // automatically refresh the results of this query when tasks change.\n  entities: [Task]\n}\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},"// ...\n\nquery getTasks {\n  // We specify that JS implementation of the query (which is an async JS function)\n  // can be found in `src/server/queries.js` as the named export `getTasks`.\n  // Use '@server' to reference files inside the src/server folder.\n  fn: import { getTasks } from \"@server/queries.js\",\n  // We tell Wasp that this query is doing something with entity `Task`. With that, Wasp will\n  // automatically refresh the results of this query when tasks change.\n  entities: [Task]\n}\n")),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"Even if you use TypeScript and have the file ",(0,s.kt)("inlineCode",{parentName:"p"},"queries.ts"),", you will still need to import it using the ",(0,s.kt)("inlineCode",{parentName:"p"},".js")," extension. Wasp internally uses ",(0,s.kt)("inlineCode",{parentName:"p"},"esnext")," module resolution, which always requires specifying the extension as ",(0,s.kt)("inlineCode",{parentName:"p"},".js")," (i.e., the extension used in the emitted JS file). This applies to all ",(0,s.kt)("inlineCode",{parentName:"p"},"@server")," imports (and files on the server in general). It does not apply to client files."),(0,s.kt)("p",{parentName:"admonition"},"Read more about ES modules in TypeScript ",(0,s.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/esm-node.html"},"here"),". If you're interested in the discussion and the reasoning behind this, read about it ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/issues/33588"},"in this GitHub issue"),".")))),(0,s.kt)(l.v,{mdxType:"ShowForJs"},(0,s.kt)("h3",{id:"javascript-implementation"},"JavaScript implementation"),(0,s.kt)("p",null,"Next, create a new file ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server/queries.ts")," and define the JavaScript function we've just imported in our ",(0,s.kt)("inlineCode",{parentName:"p"},"query")," declaration:")),(0,s.kt)(l.A,{mdxType:"ShowForTs"},(0,s.kt)("h3",{id:"typescript-implementation"},"TypeScript implementation"),(0,s.kt)("p",null,"Next, create a new file ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server/queries.ts")," and define the TypeScript function we've just imported in our ",(0,s.kt)("inlineCode",{parentName:"p"},"query")," declaration:")),(0,s.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/queries.js"',title:'"src/server/queries.js"'},"export const getTasks = async (args, context) => {\n  return context.entities.Task.findMany({})\n}\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/queries.ts"',title:'"src/server/queries.ts"'},'import { Task }  from "@wasp/entities"\nimport { GetTasks } from "@wasp/queries/types"\n\nexport const getTasks: GetTasks<void, Task[]> = async (args, context) => {\n  return context.entities.Task.findMany({})\n}\n')),(0,s.kt)("p",null,"Wasp automatically generates the types ",(0,s.kt)("inlineCode",{parentName:"p"},"GetTasks")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," based the contents of ",(0,s.kt)("inlineCode",{parentName:"p"},"main.wasp"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Task")," is a type corresponding to the ",(0,s.kt)("inlineCode",{parentName:"li"},"Task")," entity we've defined in ",(0,s.kt)("inlineCode",{parentName:"li"},"main.wasp"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"GetTasks")," is a generic type Wasp automatically generated based the ",(0,s.kt)("inlineCode",{parentName:"li"},"getTasks")," query we've defined in ",(0,s.kt)("inlineCode",{parentName:"li"},"main.wasp"),".")),(0,s.kt)("p",null,"You can use these types to specify the Query's input and output types. This Query doesn't expect any arguments (meaning that its input type is ",(0,s.kt)("inlineCode",{parentName:"p"},"void"),"), but it does return an array of tasks (meaning that its output type is ",(0,s.kt)("inlineCode",{parentName:"p"},"Task[]"),")"),(0,s.kt)("p",null,"Annotating the Queries is optional, but highly recommended because doing so enables ",(0,s.kt)("strong",{parentName:"p"},"full-stack type safety"),". We'll see what this means in the next section."))),(0,s.kt)("p",null,"Query function parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"args"),": ",(0,s.kt)("inlineCode",{parentName:"li"},"object"),", arguments the query is invoked with."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"context"),": ",(0,s.kt)("inlineCode",{parentName:"li"},"object"),", additional stuff provided by Wasp.")),(0,s.kt)("p",null,"Since we declared in ",(0,s.kt)("inlineCode",{parentName:"p"},"main.wasp")," that our query uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," entity, Wasp injected a ",(0,s.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud"},"Prisma client")," for the ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," entity as ",(0,s.kt)("inlineCode",{parentName:"p"},"context.entities.Task")," - we used it above to fetch all the tasks from the database."),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Queries and actions are NodeJS functions that are executed on the server. Therefore, we put them in the ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server")," folder.")),(0,s.kt)("h2",{id:"invoking-the-query-on-the-frontend"},"Invoking the Query on the frontend"),(0,s.kt)("p",null,"We've just said that the queries we write are executed on the server, but Wasp will generate client-side query functions (taking care of serialization, network calls, and cache invalidation in the background). Let's finally use the query we've just created, ",(0,s.kt)("inlineCode",{parentName:"p"},"getTasks"),", in our React component to list the tasks:"),(0,s.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'{1-2,5-14,17-36} title="src/client/MainPage.jsx"',"{1-2,5-14,17-36}":!0,title:'"src/client/MainPage.jsx"'},'import getTasks from "@wasp/queries/getTasks"\nimport { useQuery } from "@wasp/queries"\n\nconst MainPage = () => {\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isLoading && "Loading..."}\n      {error && "Error: " + error}\n    </div>\n  )\n}\n\nconst Task = ({ task }) => {\n  return (\n    <div>\n      <input type="checkbox" id={String(task.id)} checked={task.isDone} />\n      {task.description}\n    </div>\n  )\n}\n\nconst TasksList = ({ tasks }) => {\n  if (!tasks?.length) return <div>No tasks</div>\n\n  return (\n    <div>\n      {tasks.map((task, idx) => (\n        <Task task={task} key={idx} />\n      ))}\n    </div>\n  )\n}\n\nexport default MainPage\n'))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'{1-3,6-15,18-37} title="src/client/MainPage.tsx"',"{1-3,6-15,18-37}":!0,title:'"src/client/MainPage.tsx"'},'import getTasks from "@wasp/queries/getTasks"\nimport { useQuery } from "@wasp/queries"\nimport { Task } from "@wasp/entities"\n\nconst MainPage = () => {\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isLoading && "Loading..."}\n      {error && "Error: " + error}\n    </div>\n  )\n}\n\nconst Task = ({ task }: { task: Task }) => {\n  return (\n    <div>\n      <input type="checkbox" id={String(task.id)} checked={task.isDone} />\n      {task.description}\n    </div>\n  )\n}\n\nconst TasksList = ({ tasks }: { tasks: Task[] }) => {\n  if (!tasks?.length) return <div>No tasks</div>\n\n  return (\n    <div>\n      {tasks.map((task, idx) => (\n        <Task task={task} key={idx} />\n      ))}\n    </div>\n  )\n}\n\nexport default MainPage\n')))),(0,s.kt)(l.v,{mdxType:"ShowForJs"},(0,s.kt)("p",null,"Most of this code is just regular React, the only exception being the two special ",(0,s.kt)("inlineCode",{parentName:"p"},"@wasp")," imports:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"import getTasks from '@wasp/queries/getTasks'")," - Gives us our freshly defined Wasp query."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"import { useQuery } from '@wasp/queries'")," - Gives us Wasp's ",(0,s.kt)("a",{parentName:"li",href:"/docs/language/features#the-usequery-hook"},"useQuery")," React hook which is actually just a thin wrapper over ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/tannerlinsley/react-query"},"react-query"),"'s ",(0,s.kt)("a",{parentName:"li",href:"https://react-query.tanstack.com/docs/guides/queries"},"useQuery")," hook, behaving very similarly while offering some extra integration with Wasp."))),(0,s.kt)(l.A,{mdxType:"ShowForTs"},(0,s.kt)("p",null,"Most of this code is just regular React, the only exception being the three special ",(0,s.kt)("inlineCode",{parentName:"p"},"@wasp")," imports:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"import getTasks from '@wasp/queries/getTasks'")," - Gives us our freshly defined Wasp query."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"import { useQuery } from '@wasp/queries'")," - Gives us Wasp's ",(0,s.kt)("a",{parentName:"li",href:"/docs/language/features#the-usequery-hook"},"useQuery")," React hook which is actually just a thin wrapper over ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/tannerlinsley/react-query"},"react-query"),"'s ",(0,s.kt)("a",{parentName:"li",href:"https://react-query.tanstack.com/docs/guides/queries"},"useQuery")," hook, behaving very similarly while offering some extra integration with Wasp."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"import { Task } from '@wasp/entities'")," - The type for Task entity we've defined in ",(0,s.kt)("inlineCode",{parentName:"li"},"main.wasp"),".")),(0,s.kt)("p",null,"Notice how you didn't need to tell TypeScript anything about the Query's response data - TypeScript inferred it automatically."),(0,s.kt)("p",null,"Because we've previously annotated the Query's backend implementation with ",(0,s.kt)("inlineCode",{parentName:"p"},"GetTasks<void, Task[]>"),", Wasp knows the response data's correct type (i.e., ",(0,s.kt)("inlineCode",{parentName:"p"},"Task[]"),") on the frontend. We call this feature ",(0,s.kt)("strong",{parentName:"p"},"full-stack type safety"),".")),(0,s.kt)("p",null,"We could have called the Query directly with ",(0,s.kt)("inlineCode",{parentName:"p"},"getTasks()"),", but wrapping it with ",(0,s.kt)("inlineCode",{parentName:"p"},"useQuery(getTasks)")," makes it reactive. More precisely, React will re-render the component every time the Query's result changes."),(0,s.kt)("p",null,'With these changes, you should be seeing the text "No tasks" on the screen:'),(0,s.kt)("img",{alt:"Todo App - No Tasks",src:(0,o.Z)("img/todo-app-no-tasks.png"),style:{border:"1px solid black"}}),(0,s.kt)("p",null,"Next, let's create some tasks!"))}y.isMDXComponent=!0}}]);